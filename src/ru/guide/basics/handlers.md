# Хендлеры (обработчики)

Следующий важный кирпичик — ваши _хендлеры (обработчики)_. Они также иногда называются "объекты представления".

Обработчик в Sanic - это любой вызываемый объект, который принимает в качестве аргумента как минимум экземпляр объекта `Request`, и возвращает экземпляр `HTTPResponse` или корутину, которая делает то же самое.



---:1

В смысле? :confused:

Это **функция**; либо синхронная, либо асинхронная.

Задача хендлера заключается в том, чтобы ответить эндпоинту и что-то сделать. Здесь будет находиться большая часть вашей бизнес-логики. :--:1
```python
def i_am_a_handler(request):
    return HTTPResponse()

async def i_am_ALSO_a_handler(request):
    return HTTPResponse()
```
:---

::: Совет Внимание! Если вы хотите узнать больше о инкапсуляции вашей логики, изучите [Объекты представления на основе классов](/guide/advanced/class-based-views.md). ::: ---:1 Таким образом, всё, что вам нужно сделать, это присоединить его к эндпоинту. Подробнее мы скоро разберёмся с этим в разделе [Маршрутизация](./routing.md).

Рассмотрим практический пример.

- Мы используем в нашем приложении удобный декоратор: `@app.get()`
- И не менее удобный метод для генерации объекта ответа: `text()`

Миссия выполнена :muscle: :--:1
```python
from sanic.response import text

@app.get("/foo")
async def foo_handler(request):
    return text("I said foo!")
```
:---

---

## Несколько слов об _асинхронной парадигме_...

---:1

Разумеется, писать синхронные обработчики абсолютно допустимо.

В этом примере мы используем _блокирующий_ `time.sleep()` для моделирования 100 мс времени обработки. Например, это представляет собой получение данных из БД или со стороннего веб-сайта.

Используя четыре (4) рабочих процесса и общей механизм бенчмаркинга, получаем:

- **956** запросов за 30.10 сек
- Или около **31.76** запросов в секунду :--:1
```python
@app.get("/sync")
def sync_handler(request):
    time.sleep(0.1)
    return text("Done.")
```
:---

---:1

Просто переписав код в асинхронный `asyncio.sleep()`, мы видим невероятное изменение производительности. :rocket:

Используя те же четыре (4) рабочих процесса, получаем:

- **115,590** запроса за 30.08 сек
- или около **3,843.17** запросов в секунду

:flushed:

Ладно... Это до смешного чересчур драматичный результат. И любой бенчмарк, который вы видите, по сути очень предвзятый. Этот пример предназначен для демонстрации общего преимущества `async/await` в веб-мире. Полученные результаты, безусловно, будут различными. Инструменты, такие как Sanic и другие асинхронные библиотеки Python, не являются волшебными пулями, делающими вещи быстрее. Они делают их _более эффективными_.

В нашем примере асинхронная версия гораздо лучше, потому что пока один запрос спит, она способна начать выполнять другой, и другой, и другой, и другой...

Но в этом-то всё дело! Sanic быстрый, потому что он берет все доступные ресурсы и выжимает из них производительность. Он может одновременно обрабатывать много запросов, что означает больше запросов в секунду.

:--:1
```python
@app.get("/async")
async def async_handler(request):
    await asyncio.sleep(0.1)
    return text("Done.")
```
:---

::: Предупреждение Распространенная ошибка!

Не делайте этого! Вам нужно пинговать веб-страницу. Что вы используете? `pip install ваша-любимая-request-библиотека` :see_no_evil:

Вместо этого попробуйте использовать клиент, умеющий в `async/await`. Ваш сервер будет вам благодарен. Избегайте использования блокирующих инструментов, предпочитая те, которые хорошо работают в асинхронной экосистеме. Если вам нужны рекомендации, ознакомьтесь с [Awesome Sanic](https://github.com/mekicha/awesome-sanic).

Sanic использует [httpx](https://www.python-httpx.org/) внутри пакета тестирования (sanic-testing) :wink:.

:::

---

## Полностью аннотированный обработчик

Для тех, кто использует аннотации типов...

```python
from sanic.response import HTTPResponse, text
from sanic.request import Request

@app.get("/typed")
async def typed_handler(request: Request) -> HTTPResponse:
    return text("Done.")
```
